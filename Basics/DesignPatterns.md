# 设计模式的六大原则 

## 0、单一职责原则（Single responsibility principle）

每个类都应该有一个单一的功能，并且该功能应该由这个类完全封装起来。

## 1、开闭原则（Open Close Principle）

对扩展开放，对修改关闭。

## 2、里氏代换原则（Liskov Substitution Principle）

任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。

## 3、依赖反转原则（Dependence Inversion Principle）

指一种特定的解耦形式，高层次的模块不依赖于低层次的模块的实现细节，依赖关系被反转，从而使得低层次模块依赖于高层次模块的需求抽象。

这个是开闭原则的基础。具体内容：面向接口编程，依赖于抽象而不依赖于具体。

## 4、接口隔离原则（Interface Segregation Principle）

拆分非常庞大臃肿的接口成为更小的和更具体的接口，这样客户将会只需要知道他们感兴趣的方法。

使用多个隔离的接口，比使用单个接口要好。目的是系统解开耦合，从而容易重构，更改和重新部署。

## 5、迪米特法则（最少知道原则）（Demeter Principle）

一个对象应当对其他对象有尽可能少的了解

## 6、合成复用原则（Composite Reuse Principle）

原则是尽量使用合成/聚合的方式，而不是使用继承。尽量使用关联关系来取代继承关系



# 设计模式分类

## 创建型模式(6)

* 简单工厂模式（Simple Factory）
    * 根据参数的不同返回不同类的实例
* 工厂方法模式（Factory Method）
    * 定义一个用于创建对象的接口，让子类决定实例化那个类
* 抽象工厂模式（Abstract Factory）
    * 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。为一个产品族提供了统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类。
    * 两者区别： 工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。 工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个
* 建造者模式/生成器模式（Builder）
    * 将复杂对象的构建和它的表示分离。将建造过程抽象出来，使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。
* 原型模式（Prototype）
    * 通过“复制、克隆”一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的“原型”，这个原型是可定制的。多用于创建复杂的或者耗时的实例
* 单例模式（Singleton）
    * 3个要点：某个类只能有一个实例；必须自行创建这个实例；必须自行向整个系统提供这个实例

## 结构型模式(6)

* 适配器模式(Adapter Pattern)
    * 将某个类的接口转换成客户端期望的另一个接口表示，消除由于接口不匹配所造成的兼容性问题
* 装饰器模式(Decorator Pattern)
    * 将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器
    * 装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。
* 代理模式(Proxy Pattern)
    * 给某一个对象提供一个代理，并由代理对象控制对原对象的引用。客户不想或者不能直接引用一个对 象，通过“代理”来实现间接引用
* 外观模式(Facade Pattern)
    * 外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
* 桥接模式(Bridge Pattern)
    * 将抽象部分与它的实现部分分离，使它们都可以独立地变化
* 享元模式(Flyweight Pattern)
    * 通过共享技术实现相同或相似对象的重用。在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个享元池用于存储具有相同内部状态的享元对象

## 行为型模式(11)

* 命令模式(Command Pattern)
    * 将一个请求封装为一个对象，对发送者和接收者完全解耦
* 中介者模式(Mediator Pattern)
    * 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互
* 观察者模式(Observer Pattern)
    * 定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新
* 状态模式(State Pattern)
    * 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。它将与特定状态相关的行为局部化，并且将不同状态的行为分割开来
* 策略模式(Strategy Pattern)
    * 定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类
* 模板方法模式(Template Method Pattern)
    * 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
    * 准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑
* 迭代子模式(Iterator Pattern)
    * 又称游标模式，顺序地访问一个聚集中的元素而不必暴露聚集的内部表象
* 责任链模式(Chain of Responsibility Pattern)
    * 很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求
* 备忘录模式(Memento Pattern)
    * 是在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态
* 访问者模式(Visitor Pattern)
    * 将算法与对象结构分离。首先我们拥有一个由许多对象构成的对象结构，这些对象的类都拥有一个accept方法用来接受访问者对象；访问者是一个接口，它拥有一个visit方法，这个方法对访问到的对象结构中不同类型的元素作出不同的反应；在对象结构的一次访问过程中，我们遍历整个对象结构，对每一个元素都实施accept方法，在每一个元素的accept方法中回调访问者的visit方法，从而使访问者得以处理对象结构的每一个元素。我们可以针对对象结构设计不同的实在的访问者类来完成不同的操作。
* 解释器模式(Interpreter Pattern)
    * 给定一种语言，定义他的文法的一种表示，并定义一个解释器，该解释器使用该 表示来解释语言中句子

